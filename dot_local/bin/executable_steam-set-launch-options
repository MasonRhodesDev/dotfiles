#!/usr/bin/env bash
#
# steam-set-launch-options - Update Steam game launch options with AMD/Wayland optimizations
#
# Usage: steam-set-launch-options <game search terms...>
# Example: steam-set-launch-options borderlands 4
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color


# Build launch options based on installed software
build_launch_options() {
    local options=""

    # AMD/RADV optimizations (always include if on AMD)
    options="AMD_VULKAN_ICD=RADV RADV_PERFTEST=aco VKD3D_CONFIG=dxr11 DXVK_ASYNC=1"

    # Wayland SDL support
    options="$options SDL_VIDEODRIVER=wayland"

    # Check for gamemode
    if command -v gamemoderun >/dev/null 2>&1; then
        options="$options gamemoderun"
    fi

    # Check for mangohud
    if command -v mangohud >/dev/null 2>&1; then
        options="$options mangohud"
    fi

    # Always end with %command%
    options="$options %command%"

    echo "$options"
}

# Default launch options template (dynamically generated)
DEFAULT_LAUNCH_OPTIONS=$(build_launch_options)

# Display which components were included/excluded
show_component_status() {
    local gamemode_available=0
    local mangohud_available=0

    command -v gamemoderun >/dev/null 2>&1 && gamemode_available=1
    command -v mangohud >/dev/null 2>&1 && mangohud_available=1

    echo -e "${YELLOW}Optional components:${NC}"

    if [[ $gamemode_available -eq 1 ]]; then
        echo -e "  ${GREEN}âœ“ gamemode${NC} - CPU/GPU performance management"
    else
        echo -e "  ${RED}âœ— gamemode${NC} - not installed"
    fi

    if [[ $mangohud_available -eq 1 ]]; then
        echo -e "  ${GREEN}âœ“ MangoHUD${NC} - performance overlay"
    else
        echo -e "  ${RED}âœ— MangoHUD${NC} - not installed"
    fi
}

# Fetch ProtonDB summary data (reports require hash that needs headless browser)
fetch_protondb_data() {
    local appid="$1"

    echo -e "${BLUE}â†’ Fetching ProtonDB summary...${NC}" >&2

    # Get summary data (tier/confidence/totals)
    local summary=$(curl -s "https://www.protondb.com/api/v1/reports/summaries/${appid}.json" 2>/dev/null)

    if [[ -z "$summary" ]] || [[ "$summary" == "null" ]]; then
        echo -e "${RED}Failed to fetch ProtonDB data${NC}" >&2
        return 1
    fi

    # Get Steam game details
    local steam_response=$(curl -s "https://store.steampowered.com/api/appdetails?appids=${appid}" 2>/dev/null)

    if [[ -z "$steam_response" ]]; then
        echo -e "${YELLOW}Failed to fetch Steam data${NC}" >&2
        steam_response="{}"
    fi

    local steam_data=$(echo "$steam_response" | jq -r ".\"${appid}\".data // {}" 2>/dev/null)

    # Extract useful info
    local game_name=$(echo "$steam_data" | jq -r '.name // "Unknown"' 2>/dev/null)
    local genres=$(echo "$steam_data" | jq -r '[.genres[]?.description] | join(", ") // "Unknown"' 2>/dev/null)
    local multiplayer=$(echo "$steam_data" | jq -r 'if (.categories[]?.description | contains("Multi-player")) then "yes" else "no" end' 2>/dev/null)

    # NOTE: Detailed user reports require a hash that ProtonDB generates client-side
    # This would need a headless browser (Playwright) to extract
    # For now, we provide summary data and direct users to ProtonDB for details

    # Compile data for LLM
    jq -n \
        --arg appid "$appid" \
        --arg name "$game_name" \
        --arg genres "$genres" \
        --arg multiplayer "$multiplayer" \
        --argjson summary "$summary" \
        '{
            appid: $appid,
            name: $name,
            genres: $genres,
            multiplayer: $multiplayer,
            protondb: $summary,
            user_reports: [],
            extracted_launch_options: ""
        }'
}

# Call Claude CLI to analyze
call_claude() {
    local prompt="$1"

    if ! command -v claude >/dev/null 2>&1; then
        return 1
    fi

    # Claude may wrap JSON in markdown code fences, extract it
    local response=$(claude -p "$prompt" 2>&1)

    # Try to extract JSON from markdown fences
    if echo "$response" | grep -q '```json'; then
        echo "$response" | sed -n '/```json/,/```/p' | sed '1d;$d'
    else
        echo "$response"
    fi
}

# Analyze ProtonDB reports using Claude API
analyze_protondb() {
    local appid="$1"
    local game_name="$2"

    echo -e "${BLUE}Analyzing ProtonDB for ${game_name}...${NC}" >&2

    # Check for required tools
    if ! command -v curl >/dev/null 2>&1 || ! command -v jq >/dev/null 2>&1; then
        echo -e "${YELLOW}curl/jq not found, skipping analysis${NC}"
        echo
        return 1
    fi

    # Fetch comprehensive game data
    echo -e "${BLUE}â†’ Fetching game data...${NC}" >&2
    local game_data=$(fetch_protondb_data "$appid")

    if [[ -z "$game_data" ]] || [[ "$game_data" == "null" ]]; then
        echo -e "${YELLOW}Could not fetch data${NC}"
        echo -e "  View: ${BLUE}https://www.protondb.com/app/${appid}${NC}"
        echo
        return 1
    fi

    # Extract basic info for display
    local tier=$(echo "$game_data" | jq -r '.protondb.tier // "unknown"')
    local confidence=$(echo "$game_data" | jq -r '.protondb.confidence // "unknown"')
    local total=$(echo "$game_data" | jq -r '.protondb.total // 0')
    local best_tier=$(echo "$game_data" | jq -r '.protondb.bestReportedTier // "unknown"')
    local trending_tier=$(echo "$game_data" | jq -r '.protondb.trendingTier // "unknown"')
    local genres=$(echo "$game_data" | jq -r '.genres // "unknown"')
    local multiplayer=$(echo "$game_data" | jq -r '.multiplayer // "unknown"')

    # Try LLM analysis if claude CLI available
    if command -v claude >/dev/null 2>&1; then
        echo -e "${BLUE}â†’ Calling Claude for analysis...${NC}" >&2

        # Build structured prompt for JSON response
        local analysis_prompt="Analyze Linux gaming compatibility for ${game_name} (App ID: ${appid}) on AMD GPU + Wayland + Arch Linux.

GAME INFO:
- Genres: ${genres}
- Multiplayer: ${multiplayer}
- ProtonDB Tier: ${tier} (${confidence} confidence, ${total} community reports)
- Best Reported: ${best_tier}
- Trending: ${trending_tier}

Provide 3-5 specific launch option configurations as JSON array. Each option should be based on ProtonDB user reports and AMD+Wayland best practices.

Output ONLY valid JSON in this exact format:
{
  \"summary\": \"1-2 sentence compatibility assessment\",
  \"options\": [
    {
      \"label\": \"Short option name\",
      \"launch_options\": \"exact launch options string\",
      \"description\": \"What this does and when to use it\",
      \"confidence\": \"high|medium|low\"
    }
  ]
}

For the confidence field, estimate community confidence based on:
- Tier (Platinum/Gold = high confidence for that config)
- Report volume (more reports = higher confidence)
- Best reported tier vs current tier (shows what's achievable)
- For \"no changes needed\": high confidence only if tier is Platinum/Gold with many reports

Include these option types:
1. If ProtonDB shows it works without changes: \"No changes needed\" with empty launch_options (confidence: high only if Platinum/Gold tier)
2. Standard AMD+Wayland optimizations (RADV, DXVK_ASYNC, etc) - confidence based on tier
3. Any game-specific tweaks mentioned in reports
4. Proton version recommendations in description
5. Wayland compatibility flags if needed

For multiplayer games, mention anti-cheat (EAC/BattlEye) in descriptions.
Direct users to https://www.protondb.com/app/${appid} in summary."

        local analysis=$(call_claude "$analysis_prompt")

        if [[ -n "$analysis" ]]; then
            # Parse JSON response
            local summary=$(echo "$analysis" | jq -r '.summary // empty' 2>/dev/null)

            if [[ -n "$summary" ]]; then
                echo -e "${GREEN}=== ProtonDB Analysis ===${NC}" >&2
                echo -e "  ${summary}" >&2
                echo >&2

                # Return ONLY the JSON for use by prompt_launch_options
                echo "$analysis"
                return 0
            fi
        fi

        # If we get here, Claude failed or returned invalid JSON
        echo -e "${RED}Failed to get analysis from Claude${NC}" >&2
        return 1
    fi

    # No claude CLI available
    echo -e "${RED}Claude CLI not found${NC}" >&2
    return 1
}

# Find Steam installation
find_steam_root() {
    local steam_paths=(
        "$HOME/.steam/steam"
        "$HOME/.local/share/Steam"
        "$HOME/.var/app/com.valvesoftware.Steam/.local/share/Steam"  # Flatpak
    )

    for path in "${steam_paths[@]}"; do
        if [[ -d "$path" ]]; then
            echo "$path"
            return 0
        fi
    done

    return 1
}

# Parse VDF format (basic parser for localconfig.vdf)
parse_vdf_get_launch_options() {
    local file="$1"
    local appid="$2"

    # Extract the LaunchOptions for specific appid
    # VDF structure: "appid" { "LaunchOptions" "value" }
    awk -v appid="$appid" '
        BEGIN { in_app=0; }
        $0 ~ "\"" appid "\"" { in_app=1; next; }
        in_app && /LaunchOptions/ {
            match($0, /"([^"]*)"[[:space:]]*$/, arr);
            print arr[1];
            exit;
        }
        in_app && /^\s*}/ { in_app=0; }
    ' "$file"
}

# Update launch options in localconfig.vdf
update_vdf_launch_options() {
    local file="$1"
    local appid="$2"
    local new_options="$3"
    local backup="${file}.backup.$(date +%s)"

    # Create backup
    cp "$file" "$backup"
    echo -e "${BLUE}Created backup: $backup${NC}"

    # Escape special characters for sed
    local escaped_options=$(printf '%s\n' "$new_options" | sed 's/[\/&]/\\&/g')

    # Use awk to update the launch options
    awk -v appid="$appid" -v newopts="$escaped_options" '
        BEGIN { in_app=0; updated=0; }

        # Found the app section
        $0 ~ "\"" appid "\"" {
            in_app=1;
            print;
            next;
        }

        # In app section, found LaunchOptions
        in_app && /LaunchOptions/ && !updated {
            # Replace or add the line
            sub(/"[^"]*"[[:space:]]*$/, "\"" newopts "\"");
            updated=1;
            print;
            next;
        }

        # Exiting app section
        in_app && /^\s*}/ {
            # If we never found LaunchOptions, add it before closing brace
            if (!updated) {
                print "\t\t\t\t\t\"LaunchOptions\"\t\t\"" newopts "\"";
                updated=1;
            }
            in_app=0;
        }

        { print }
    ' "$file" > "${file}.tmp" && mv "${file}.tmp" "$file"

    echo -e "${GREEN}Updated launch options in: $file${NC}"
}

# Search for game in Steam library
search_game() {
    local search_term="$1"
    local steam_root="$2"
    local results=()

    # Find all library folders
    local library_file="${steam_root}/steamapps/libraryfolders.vdf"
    local library_paths=("${steam_root}/steamapps")

    if [[ -f "$library_file" ]]; then
        # Parse additional library folders from vdf
        while IFS= read -r line; do
            if [[ "$line" =~ \"path\"[[:space:]]+\"([^\"]+)\" ]]; then
                library_paths+=("${BASH_REMATCH[1]}/steamapps")
            fi
        done < "$library_file"
    fi

    # Search through all manifests
    for lib_path in "${library_paths[@]}"; do
        if [[ ! -d "$lib_path" ]]; then
            continue
        fi

        for manifest in "$lib_path"/appmanifest_*.acf; do
            if [[ ! -f "$manifest" ]]; then
                continue
            fi

            # Extract appid and name
            local appid=$(basename "$manifest" | sed 's/appmanifest_\([0-9]*\)\.acf/\1/')
            local name=$(grep -E '^\s*"name"' "$manifest" | head -1 | sed 's/.*"\([^"]*\)"[^"]*$/\1/')

            # Case-insensitive search
            if echo "$name" | grep -iq "$search_term"; then
                results+=("$appid|$name")
            fi
        done
    done

    printf '%s\n' "${results[@]}"
}

# Interactive prompt for launch options
prompt_launch_options() {
    local current_options="$1"
    local options_json="$2"

    echo -e "${YELLOW}Current launch options:${NC}"
    if [[ -z "$current_options" ]]; then
        echo -e "${BLUE}  (none)${NC}"
    else
        echo -e "${BLUE}  $current_options${NC}"
    fi
    echo

    show_component_status
    echo

    # Parse options from JSON and build menu
    local option_count=$(echo "$options_json" | jq -r '.options | length' 2>/dev/null)

    if [[ -z "$option_count" ]] || [[ "$option_count" == "0" ]] || [[ "$option_count" == "null" ]]; then
        echo -e "${RED}No options available from ProtonDB analysis${NC}"
        echo -e "${YELLOW}Debug: JSON length = ${#options_json}, count = '$option_count'${NC}"
        echo -e "${YELLOW}Debug: First 200 chars of JSON: ${options_json:0:200}${NC}"
        return 1
    fi

    echo -e "${YELLOW}Available configurations:${NC}" >&2

    local i
    for ((i=0; i<option_count; i++)); do
        local label=$(echo "$options_json" | jq -r ".options[$i].label" 2>/dev/null)
        local launch_opts=$(echo "$options_json" | jq -r ".options[$i].launch_options" 2>/dev/null)
        local desc=$(echo "$options_json" | jq -r ".options[$i].description" 2>/dev/null)
        local confidence=$(echo "$options_json" | jq -r ".options[$i].confidence // \"unknown\"" 2>/dev/null)

        # Set confidence indicator
        local confidence_indicator=""
        case "$confidence" in
            high)
                confidence_indicator="${GREEN}ðŸŸ¢ High confidence${NC}"
                ;;
            medium)
                confidence_indicator="${YELLOW}ðŸŸ¡ Medium confidence${NC}"
                ;;
            low)
                confidence_indicator="${RED}ðŸ”´ Low confidence${NC}"
                ;;
            *)
                confidence_indicator="${YELLOW}â“ Unknown${NC}"
                ;;
        esac

        echo -e "  $((i+1))) ${GREEN}${label}${NC} [${confidence_indicator}]" >&2
        echo -e "     ${desc}" >&2
        if [[ -n "$launch_opts" ]]; then
            echo -e "     ${BLUE}Will set: ${launch_opts}${NC}" >&2
        else
            echo -e "     ${BLUE}Will set: (no changes)${NC}" >&2
        fi
        echo >&2
    done

    # Add "keep current" option
    echo -e "  $((option_count+1))) ${GREEN}Keep current options (cancel)${NC}" >&2
    echo -e "     ${BLUE}Will set: ${current_options:-"(none)"}${NC}" >&2
    echo >&2

    read -p "Selection [1-$((option_count+1))]: " -r choice

    if [[ -z "$choice" ]] || [[ ! "$choice" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return 1
    fi

    # Check if user chose "keep current"
    if [[ "$choice" -eq $((option_count+1)) ]]; then
        return 1  # Signal no change
    fi

    # Validate selection
    if [[ "$choice" -lt 1 ]] || [[ "$choice" -gt "$option_count" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return 1
    fi

    # Return selected launch options
    local selected_opts=$(echo "$options_json" | jq -r ".options[$((choice-1))].launch_options" 2>/dev/null)
    echo "$selected_opts"
    return 0
}

# Check if Steam is running
is_steam_running() {
    pgrep -x steam >/dev/null 2>&1 || pgrep -x steamwebhelper >/dev/null 2>&1
}

# Kill Steam
kill_steam() {
    echo -e "${YELLOW}Closing Steam...${NC}"

    if command -v steam >/dev/null 2>&1; then
        steam -shutdown 2>/dev/null &
        sleep 2
    fi

    # Force kill if still running
    if is_steam_running; then
        pkill -9 steam steamwebhelper 2>/dev/null || true
        sleep 1
    fi

    echo -e "${GREEN}Steam closed${NC}"
}

# Start Steam
start_steam() {
    echo -e "${YELLOW}Starting Steam...${NC}"

    if command -v steam >/dev/null 2>&1; then
        steam >/dev/null 2>&1 &
    elif flatpak list | grep -q com.valvesoftware.Steam; then
        flatpak run com.valvesoftware.Steam >/dev/null 2>&1 &
    else
        echo -e "${RED}Could not find Steam executable${NC}"
        return 1
    fi

    echo -e "${GREEN}Steam starting...${NC}"
}

# Main
main() {
    local dry_run=0

    # Parse flags
    if [[ "${1:-}" == "--dry-run" ]]; then
        dry_run=1
        shift
    fi

    if [[ $# -eq 0 ]]; then
        echo "Usage: $0 [--dry-run] <game search terms...>"
        echo
        echo "Options:"
        echo "  --dry-run    Show analysis and menu without making changes"
        echo
        echo "Example:"
        echo "  $0 borderlands 4"
        echo "  $0 --dry-run planetside"
        exit 1
    fi

    # Combine all arguments into search term
    local search_term="${*}"

    echo -e "${BLUE}=== Steam Launch Options Updater ===${NC}"
    echo -e "${BLUE}Search term: ${search_term}${NC}"
    echo

    # Find Steam
    local steam_root
    if ! steam_root=$(find_steam_root); then
        echo -e "${RED}Error: Could not find Steam installation${NC}"
        echo -e "${YELLOW}Expected locations:${NC}"
        echo "  ~/.steam/steam"
        echo "  ~/.local/share/Steam"
        echo "  ~/.var/app/com.valvesoftware.Steam/.local/share/Steam (Flatpak)"
        exit 1
    fi

    echo -e "${GREEN}Found Steam: ${steam_root}${NC}"
    echo

    # Search for games
    echo -e "${YELLOW}Searching for games...${NC}"
    local results
    mapfile -t results < <(search_game "$search_term" "$steam_root")

    if [[ ${#results[@]} -eq 0 ]]; then
        echo -e "${RED}No games found matching: ${search_term}${NC}"
        exit 1
    fi

    # Display results
    echo -e "${GREEN}Found ${#results[@]} game(s):${NC}"
    for i in "${!results[@]}"; do
        IFS='|' read -r appid name <<< "${results[$i]}"
        echo "  $((i+1))) [$appid] $name"
    done
    echo

    # Select game
    local selection
    if [[ ${#results[@]} -eq 1 ]]; then
        selection=0
        echo -e "${YELLOW}Auto-selecting only match${NC}"
    else
        read -p "Select game [1-${#results[@]}]: " -r selection
        selection=$((selection - 1))

        if [[ $selection -lt 0 || $selection -ge ${#results[@]} ]]; then
            echo -e "${RED}Invalid selection${NC}"
            exit 1
        fi
    fi

    IFS='|' read -r appid name <<< "${results[$selection]}"
    echo -e "${GREEN}Selected: ${name} (${appid})${NC}"
    echo

    # Analyze ProtonDB for this game and get JSON options
    local protondb_json
    protondb_json=$(analyze_protondb "$appid" "$name")

    if [[ -z "$protondb_json" ]]; then
        echo -e "${RED}Failed to get ProtonDB analysis${NC}"
        exit 1
    fi

    # Find localconfig.vdf
    local userdata_dir="${steam_root}/userdata"
    local config_files=()

    for user_dir in "$userdata_dir"/*; do
        if [[ -d "$user_dir" ]] && [[ $(basename "$user_dir") =~ ^[0-9]+$ ]]; then
            local config="${user_dir}/config/localconfig.vdf"
            if [[ -f "$config" ]]; then
                config_files+=("$config")
            fi
        fi
    done

    if [[ ${#config_files[@]} -eq 0 ]]; then
        echo -e "${RED}Error: Could not find localconfig.vdf${NC}"
        exit 1
    fi

    # Use first config (or prompt if multiple users)
    local config_file="${config_files[0]}"
    if [[ ${#config_files[@]} -gt 1 ]]; then
        echo -e "${YELLOW}Found ${#config_files[@]} Steam users:${NC}"
        for i in "${!config_files[@]}"; do
            local userid=$(basename "$(dirname "$(dirname "${config_files[$i]}")")")
            echo "  $((i+1))) User ID: $userid"
        done
        read -p "Select user [1-${#config_files[@]}]: " -r user_selection
        config_file="${config_files[$((user_selection - 1))]}"
    fi

    echo -e "${GREEN}Using config: ${config_file}${NC}"
    echo

    # Get current launch options
    local current_options
    current_options=$(parse_vdf_get_launch_options "$config_file" "$appid")

    # Prompt for new options with ProtonDB recommendations
    local new_options
    if ! new_options=$(prompt_launch_options "$current_options" "$protondb_json"); then
        echo -e "${YELLOW}No changes made${NC}"
        exit 0
    fi

    echo
    echo -e "${YELLOW}New launch options:${NC}"
    echo -e "${GREEN}  $new_options${NC}"
    echo

    if [[ $dry_run -eq 1 ]]; then
        echo -e "${YELLOW}[DRY RUN] Would update launch options but not actually applying${NC}"
        echo -e "${BLUE}Game: ${name} (${appid})${NC}"
        echo -e "${BLUE}Options: ${new_options}${NC}"
        exit 0
    fi

    read -p "Apply these launch options? [Y/n]: " -r confirm
    confirm=${confirm:-Y}

    if [[ ! "$confirm" =~ ^[Yy] ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        exit 0
    fi

    # Close Steam if running
    if is_steam_running; then
        kill_steam
        sleep 2
    fi

    # Update config
    update_vdf_launch_options "$config_file" "$appid" "$new_options"

    echo
    read -p "Start Steam now? [Y/n]: " -r start_confirm
    start_confirm=${start_confirm:-Y}

    if [[ "$start_confirm" =~ ^[Yy] ]]; then
        start_steam
    fi

    echo
    echo -e "${GREEN}âœ“ Launch options updated successfully!${NC}"
    echo -e "${BLUE}Game: ${name} (${appid})${NC}"
    echo -e "${BLUE}Options: ${new_options}${NC}"
}

main "$@"
