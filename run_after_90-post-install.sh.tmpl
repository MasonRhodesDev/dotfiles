#!/bin/bash
# Post-installation tasks
# Service health checks, group membership warnings, environment setup

set +e
set -u
set -o pipefail

SCRIPT_DIR="{{ .chezmoi.homeDir }}/.local/share/chezmoi-libs"
source "$SCRIPT_DIR/lib-logging.sh"
source "$SCRIPT_DIR/lib-state.sh"
source "$SCRIPT_DIR/lib-helpers.sh"

PHASE="post-install"

# Initialize logging
init_log_file "$PHASE"

log_phase_start "Post-Installation Tasks"

# Initialize state
init_state_db

# Service health checks
log_info "Checking service status..."

SERVICES_TO_CHECK=()

# Check if MongoDB was installed
if command -v mongosh &>/dev/null || command -v mongo &>/dev/null; then
    SERVICES_TO_CHECK+=("mongod:mongodb")
fi

# Check if Docker was installed
if command -v docker &>/dev/null; then
    SERVICES_TO_CHECK+=("docker:docker")
fi

for service_entry in "${SERVICES_TO_CHECK[@]}"; do
    # Split on colon (fedora_name:arch_name)
    IFS=: read -r fedora_service arch_service <<< "$service_entry"

    service="$fedora_service"
    if [ "$(get_distro)" = "arch" ]; then
        service="$arch_service"
    fi

    if systemctl is-active "$service" &>/dev/null; then
        log_info "✓ $service is running"
    elif systemctl is-enabled "$service" &>/dev/null; then
        log_warn "⚠ $service is enabled but not running"
        log_info "Starting $service..."
        sudo systemctl start "$service" || log_error "Failed to start $service"
    else
        log_debug "$service not installed or not enabled"
    fi
done

# Group membership warnings
log_info "Checking group memberships..."

GROUPS_ADDED=()

if command -v docker &>/dev/null; then
    if check_user_in_group "docker"; then
        # Check if group was added this session (not in initial groups)
        if ! echo "$GROUPS_INITIAL" | grep -q "\bdocker\b" 2>/dev/null; then
            GROUPS_ADDED+=("docker")
        fi
    fi
fi

if [ ${#GROUPS_ADDED[@]} -gt 0 ]; then
    echo ""
    log_warn "━━━ IMPORTANT ━━━"
    log_warn "You were added to the following groups:"
    printf '  • %s\n' "${GROUPS_ADDED[@]}"
    echo ""
    log_warn "Log out and back in for group changes to take effect"
    log_warn "Or run: newgrp docker (temporary for current shell)"
    echo ""
fi

# Reload Hyprland configuration if running
if command -v hyprctl &>/dev/null && pgrep -x Hyprland &>/dev/null; then
    log_info "Reloading Hyprland configuration..."
    if hyprctl reload &>/dev/null; then
        log_info "✓ Hyprland configuration reloaded"
    else
        log_warn "⚠ Failed to reload Hyprland configuration"
    fi
fi

# Check waybar service status
if systemctl --user is-active waybar &>/dev/null; then
    log_info "✓ waybar service is running"
elif systemctl --user is-enabled waybar &>/dev/null; then
    log_warn "⚠ waybar is enabled but not running"
    log_info "Restarting waybar..."
    if systemctl --user restart waybar; then
        log_info "✓ waybar service restarted"
    else
        log_error "✗ Failed to restart waybar service"
    fi
else
    log_debug "waybar service not enabled"
fi

# Enable waybar watchdog timer
if systemctl --user list-unit-files waybar-watchdog.timer &>/dev/null; then
    if ! systemctl --user is-enabled waybar-watchdog.timer &>/dev/null; then
        log_info "Enabling waybar watchdog timer..."
        systemctl --user enable waybar-watchdog.timer &>/dev/null || log_warn "Failed to enable waybar-watchdog.timer"
    fi
    if ! systemctl --user is-active waybar-watchdog.timer &>/dev/null; then
        log_info "Starting waybar watchdog timer..."
        systemctl --user start waybar-watchdog.timer &>/dev/null || log_warn "Failed to start waybar-watchdog.timer"
    fi
    log_info "✓ waybar watchdog timer is active"
fi

# Enable waybar config reload watcher
if systemctl --user list-unit-files waybar-reload.path &>/dev/null; then
    if ! systemctl --user is-enabled waybar-reload.path &>/dev/null; then
        log_info "Enabling waybar config reload watcher..."
        systemctl --user enable waybar-reload.path &>/dev/null || log_warn "Failed to enable waybar-reload.path"
    fi
    if ! systemctl --user is-active waybar-reload.path &>/dev/null; then
        log_info "Starting waybar config reload watcher..."
        systemctl --user start waybar-reload.path &>/dev/null || log_warn "Failed to start waybar-reload.path"
    fi
    log_debug "waybar config reload watcher is active"
fi

# Enable chezmoi daemon timer (auto-update dotfiles)
if systemctl --user list-unit-files chezmoi-daemon.timer &>/dev/null; then
    if ! systemctl --user is-enabled chezmoi-daemon.timer &>/dev/null; then
        log_info "Enabling chezmoi daemon timer..."
        systemctl --user enable chezmoi-daemon.timer &>/dev/null || log_warn "Failed to enable chezmoi-daemon.timer"
    fi
    if ! systemctl --user is-active chezmoi-daemon.timer &>/dev/null; then
        log_info "Starting chezmoi daemon timer..."
        systemctl --user start chezmoi-daemon.timer &>/dev/null || log_warn "Failed to start chezmoi-daemon.timer"
    fi
    log_debug "chezmoi daemon timer is active"
fi

# Enable Hyprland config reload listener for waybar
if systemctl --user list-unit-files hyprland-configreload-listener.service &>/dev/null; then
    if ! systemctl --user is-enabled hyprland-configreload-listener.service &>/dev/null; then
        log_info "Enabling Hyprland config reload listener..."
        systemctl --user enable hyprland-configreload-listener.service &>/dev/null || log_warn "Failed to enable hyprland-configreload-listener.service"
    fi
    if ! systemctl --user is-active hyprland-configreload-listener.service &>/dev/null; then
        log_info "Starting Hyprland config reload listener..."
        systemctl --user start hyprland-configreload-listener.service &>/dev/null || log_warn "Failed to start hyprland-configreload-listener.service"
    fi
    log_debug "Hyprland config reload listener is active"
fi

# Enable lid handler on laptops
if [ -e /proc/acpi/button/lid ] && systemctl --user list-unit-files lid-handler.service &>/dev/null; then
    if ! systemctl --user is-enabled lid-handler.service &>/dev/null; then
        log_info "Enabling laptop lid handler..."
        systemctl --user enable lid-handler.service &>/dev/null || log_warn "Failed to enable lid-handler.service"
    fi
    if ! systemctl --user is-active lid-handler.service &>/dev/null; then
        log_info "Starting laptop lid handler..."
        systemctl --user start lid-handler.service &>/dev/null || log_warn "Failed to start lid-handler.service"
    fi
    log_debug "laptop lid handler is active"
fi

# Environment setup reminders
NEEDS_SHELL_RESTART=false

if command -v fnm &>/dev/null; then
    if ! echo "$PATH" | grep -q ".local/share/fnm"; then
        log_warn "fnm is installed but not in PATH"
        log_warn "Restart your shell or run: source ~/.bashrc"
        NEEDS_SHELL_RESTART=true
    fi
fi

if command -v bun &>/dev/null; then
    if ! echo "$PATH" | grep -q ".bun/bin"; then
        log_warn "bun is installed but not in PATH"
        log_warn "Restart your shell or run: source ~/.bashrc"
        NEEDS_SHELL_RESTART=true
    fi
fi

if [ "$NEEDS_SHELL_RESTART" = true ]; then
    echo ""
    log_info "Some tools require a shell restart to be available in PATH"
fi

# Initialize theme system
if command -v lmtt &>/dev/null; then
    log_info "Initializing theme system..."
    THEME_STATE="$HOME/.cache/theme_state"
    MODE="dark"
    if [ -f "$THEME_STATE" ]; then
        MODE=$(cat "$THEME_STATE")
    fi
    log_info "Applying $MODE theme..."
    lmtt switch "$MODE" || log_warn "Failed to apply theme"
else
    log_debug "lmtt command not found, skipping theme initialization"
fi

log_phase_end "Post-Installation"
exit 0
